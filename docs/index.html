<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>@bluejay/access-control</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">@bluejay/access-control</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> @bluejay/access-control</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#accesscontrol" id="accesscontrol" style="color: inherit; text-decoration: none;">
					<h1>AccessControl</h1>
				</a>
				<p><a href="https://www.npmjs.com/package/@bluejay/access-control"><img src="https://img.shields.io/npm/v/@bluejay/access-control.svg?style=flat-square" alt="npm"></a>
					<a href="https://www.npmjs.com/package/@bluejay/access-control"><img src="https://img.shields.io/npm/dm/@bluejay/access-control.svg?style=flat-square" alt="npm"></a>
				<a href="https://www.npmjs.com/package/@bluejay/access-control"><img src="https://img.shields.io/npm/l/@bluejay/access-control.svg?style=flat-square" alt="npm"></a></p>
				<p>Simple, flexible and reliable <a href="https://en.wikipedia.org/wiki/Role-based_access_control">RBAC</a> / <a href="https://en.wikipedia.org/wiki/Attribute-based_access_control">ABAC</a> access control for NodeJS and Typescript.</p>
				<a href="#requirements" id="requirements" style="color: inherit; text-decoration: none;">
					<h2>Requirements</h2>
				</a>
				<ul>
					<li><code>node &gt;= 7</code></li>
					<li><code>typescript &gt;= 2.4</code></li>
				</ul>
				<a href="#installation" id="installation" style="color: inherit; text-decoration: none;">
					<h2>Installation</h2>
				</a>
				<p><code>npm i @bluejay/access-control</code></p>
				<a href="#guide" id="guide" style="color: inherit; text-decoration: none;">
					<h2>Guide</h2>
				</a>
				<a href="#simple-role-based-access-control" id="simple-role-based-access-control" style="color: inherit; text-decoration: none;">
					<h3>Simple role based access control</h3>
				</a>
				<p>Many applications define a list of roles which are assigned to users and thus define what those users can or cannot do. This is called RBAC (Role Based Access Control) and is one of the most used access control mechanism. Below we&#39;ll take a look at how this can be implemented with Bluejay&#39;s AccessControl.</p>
				<p>First, let&#39;s define some application context:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// Here we define 2 roles: one for regular customers, and a special admin role for internal users.</span>
<span class="hljs-comment">// Note that Bluejay's AccessControl doesn't require any specific role values nor the use of an enum. A role in Bluejay's world is as simple as a string.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> Role {
  CUSTOMER = <span class="hljs-string">'customer'</span>,
  ADMIN = <span class="hljs-string">'admin'</span>
}

<span class="hljs-comment">// This interface describes the attributes of the "post" entity, which represents blog posts in our example application.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IPost {
  id: integer;
  title: <span class="hljs-built_in">string</span>;
  content: <span class="hljs-built_in">string</span>;
  created_by: integer;
  created_at: <span class="hljs-built_in">Date</span>;
  updated_at: <span class="hljs-built_in">Date</span>;
}</code></pre>
				<p>Next, we&#39;ll define a <code>Subject</code> class to hold our user&#39;s information and communicate with Bluejay&#39;s AccessControl. A <em>subject</em> is just a fancy security term that defines a security view of an application user. Note that a subject does not have to represent a human being and could for example be a 3rd party system that connects to your application.</p>
				<p>For the sake of simplicity, we&#39;ll assume that all users are stored in the same database table and are uniquely identified by an <code>id</code> integer. We&#39;ll implement the abstract <code>getPrincipal()</code> method in order to let Bluejay know what attribute to use as an identifier. A <code>principal</code> is another security term that defines an identifying attribute for an application user.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">'@bluejay/access-control'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> UserSubject <span class="hljs-keyword">extends</span> Subject&lt;{ id: <span class="hljs-built_in">number</span> }&gt; {
  <span class="hljs-keyword">public</span> getPrincipal() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'id'</span>);
  }

  <span class="hljs-comment">// Note: you can perfectly add custom methods here</span>
}</code></pre>
				<p>We&#39;ll then need to tell Bluejay where to look for permissions. AccessControl comes package with a built-in <code>MemoryStore</code> that allows you to manage permissions in memory. We&#39;ll cover persistent stores <a href="#stores">later in this documentation</a>.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { MemoryStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@bluejay/access-control'</span>;

<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> MemoryStore();</code></pre>
				<p>Now let&#39;s create an instance of Bluejay&#39;s AccessControl to be used across the application.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { AccessControl } <span class="hljs-keyword">from</span> <span class="hljs-string">'@bluejay/access-control'</span>;

<span class="hljs-keyword">const</span> accessControl = <span class="hljs-keyword">new</span> AccessControl({ store });</code></pre>
				<p>We&#39;re now ready to declare permissions:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> customer = <span class="hljs-keyword">new</span> UserSubject({ id: <span class="hljs-number">1</span> });
<span class="hljs-keyword">const</span> admin = <span class="hljs-keyword">new</span> UserSubject({ id: <span class="hljs-number">2</span> });

store
  .addPermissionToRole(Role.CUSTOMER, { <span class="hljs-comment">// Limited power for customers</span>
    id: <span class="hljs-string">'CustomerPostsPolicy'</span>,
    effect: <span class="hljs-string">'allow'</span>,
    resource: <span class="hljs-string">'posts'</span>,
    action: [<span class="hljs-string">'create'</span>, <span class="hljs-string">'read'</span>]
  })
  .addPermissionToRole(Role.ADMIN, { <span class="hljs-comment">// Full power for admins</span>
    id: <span class="hljs-string">'AdminPolicy'</span>,
    effect: <span class="hljs-string">'allow'</span>,
    resource: <span class="hljs-string">'*'</span>,
    action: <span class="hljs-string">'*'</span>
  })
  .addRoleToSubject(customer, Role.CUSTOMER)
  .addRoleToSubject(admin, Role.ADMIN);</code></pre>
				<p>We can finally check our users permissions:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">await</span> accessControl.can(customer, <span class="hljs-string">'posts'</span>, <span class="hljs-string">'create'</span>); <span class="hljs-comment">// true</span>
<span class="hljs-keyword">await</span> accessControl.can(customer, <span class="hljs-string">'posts'</span>, <span class="hljs-string">'update'</span>); <span class="hljs-comment">// false</span>
<span class="hljs-keyword">await</span> accessControl.can(admin, <span class="hljs-string">'posts'</span>, <span class="hljs-string">'delete'</span>); <span class="hljs-comment">// true</span></code></pre>
				<a href="#simple-attribute-based-access-control" id="simple-attribute-based-access-control" style="color: inherit; text-decoration: none;">
					<h3>Simple attribute based access control</h3>
				</a>
				<p>ABAC (Attribute Based Access Control) provides an fine-grained control over which attributes a particular role is able to access. The following examples assume that you have already read the RBAC examples.</p>
				<p>Let&#39;s create some more specific permission:</p>
				<pre><code class="language-typescript">store
  .addPermissionToRole(Role.CUSTOMER, {
    id: <span class="hljs-string">'CustomerCreatePostPolicy'</span>,
    effect: <span class="hljs-string">'allow'</span>,
    resource: <span class="hljs-string">'posts'</span>,
    action: <span class="hljs-string">'create'</span>,
    condition: {
      stringEquals: {
        forAllValues: {
          bodyAttributes: [<span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>]
        }
      }
    }
  })
  .addPermissionToRole(Role.ADMIN, {
    id: <span class="hljs-string">'AdminPolicy'</span>,
    effect: <span class="hljs-string">'allow'</span>,
    resource: <span class="hljs-string">'*'</span>,
    action: <span class="hljs-string">'*'</span>
  });</code></pre>
				<p>The <code>condition</code> part defines a set of rules used to evaluate whether or not the permission is applicable. Conditions are defined in a 3 levels object that can be described as follows:</p>
				<ul>
					<li>operator (<code>stringEquals</code> in our case)<ul>
							<li>modifier (<code>forAllValues</code> in our case)<ul>
									<li>attributeName (<code>bodyAttributes</code> in our case)</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
				<p>An <code>operator</code> defines what type of data we&#39;re comparing and how to compare then. Example operators are <code>dateEquals</code>, <code>numberGreaterThan</code>, <code>bool</code>, <code>stringNotEquals</code>, ...
					A <code>modifier</code> defines the type of input data (single value vs. array) as well as how to interpret them. Example modifiers are <code>forAllValues</code>, <code>simpleValue</code>, <code>simpleValueIfExists</code>
				An <code>attributeName</code> defines an attribute that <em>may be</em> be present in the <code>environment</code>. Our example defines <code>bodyAttributes</code> which is meant to contain the attributes of the POST request&#39;s body.</p>
				<p>For more about condition modifiers, see the next section.</p>
				<p>We are essentially saying that <em>for all values</em> in <code>bodyAttributes</code>, we expect to find an <em>equal string</em> in the provided condition values. Stated another way, we expect the body to only contain attributes that are listed in the condition values.</p>
				<p>We&#39;ll be building a simple express POST endpoint that allows consumers to create blog posts. We&#39;ll assume that the request has been authenticated and the current user stored as <code>req.user</code>. We&#39;ll also assume that the request&#39;s body has already been validated and contains only valid values in regards to the data model.</p>
				<p>We will be making use of Bluejay&#39;s <code>Keys</code> utility, which helps performing various attribute related operations on objects and arrays, in a format that is understood by Bluejay.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Keys } <span class="hljs-keyword">from</span> <span class="hljs-string">'@bluejay/access-control'</span>;

app.post(<span class="hljs-string">'/posts'</span>, authenticate(), validatePostBody(), <span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
  <span class="hljs-keyword">const</span> body: Partial&lt;IPost&gt; = req.body;

  <span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> UserSubject(req.user);

  <span class="hljs-comment">// We're passing the body's attributes in the environment. Keys.list() will make sure that the resulting list of attributes</span>
  <span class="hljs-comment">// is understandable by Bluejay.</span>
  <span class="hljs-keyword">const</span> isAllowed = <span class="hljs-keyword">await</span> accessControl.can(subject, <span class="hljs-string">'posts'</span>, <span class="hljs-string">'create'</span>, { bodyAttributes: Keys.list(body) });

  <span class="hljs-comment">// For an admin user, since no attributes condition has been defined in the permission, any body will be authorized.</span>
  <span class="hljs-comment">// For a customer user, the access will only be authorized if all attributes in the body are listed in the permission.</span>

  <span class="hljs-keyword">if</span> (isAllowed) {
    <span class="hljs-keyword">await</span> postService.create(body);
    res.status(<span class="hljs-number">201</span>).end();
  } <span class="hljs-keyword">else</span> {
    res.status(<span class="hljs-number">403</span>).end();
  }
});</code></pre>
				<a href="#condition-operators" id="condition-operators" style="color: inherit; text-decoration: none;">
					<h3>Condition operators</h3>
				</a>
				<p>Condition operators define how environment values are compared to condition values.</p>
				<p>Condition values are defined as strings no matter their type and further casted at runtime. This allows consumers to store permissions in a schema based storage system such a RDMS without worrying about casting values themselves or storing condition values in separate tables because of the type differences.</p>
				<a href="#string-operators" id="string-operators" style="color: inherit; text-decoration: none;">
					<h4>String operators</h4>
				</a>
				<a href="#codestringequalscode" id="codestringequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>stringEquals</code></h5>
				</a>
				<pre><code>const condition = {
  stringEquals: {
    simpleValue: {
      foo: <span class="hljs-string">'bar'</span>
    }
  }
};


const ok = {
  foo: <span class="hljs-string">'bar'</span> <span class="hljs-regexp">//</span> This will pass because foo === <span class="hljs-string">'bar'</span>
};

const nok = {
  foo: <span class="hljs-string">'baz'</span> <span class="hljs-regexp">//</span> This won<span class="hljs-string">'t pass because foo !== '</span>ba<span class="hljs-string">r'
};

const nok2 = {
  foo: undefined // This won'</span>t pass because foo !== <span class="hljs-string">'bar'</span>
}</code></pre>
				<a href="#codestringnotequalscode" id="codestringnotequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>stringNotEquals</code></h5>
				</a>
				<pre><code>const condition = {
  stringNotEquals: {
    simpleValue: {
      foo: <span class="hljs-string">'bar'</span>
    }
  }
};


const ok = {
  foo: <span class="hljs-string">'baz'</span> // This will <span class="hljs-keyword">pass</span> because foo !== <span class="hljs-string">'bar'</span>
};

const nok = {
  foo: <span class="hljs-string">'bar'</span> // This won<span class="hljs-string">'t pass because foo === '</span>ba<span class="hljs-string">r'
};

const nok2 = {
  foo: undefined // This won'</span>t <span class="hljs-keyword">pass</span> because foo <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a string
}</code></pre>
				<a href="#codestringimpliescode" id="codestringimpliescode" style="color: inherit; text-decoration: none;">
					<h5><code>stringImplies</code></h5>
				</a>
				<pre><code>const condition = {
  stringImplies: {
    simpleValue: {
      foo: <span class="hljs-string">'bar*'</span>
    }
  }
};


const ok = {
  foo: <span class="hljs-string">'bar'</span> // This will <span class="hljs-keyword">pass</span> because foo matches <span class="hljs-string">'bar'</span>
};

const ok2 = {
  foo: <span class="hljs-string">'barack'</span> // This will <span class="hljs-keyword">pass</span> because foo matches <span class="hljs-string">'bar'</span>
};

const nok = {
  foo: <span class="hljs-string">'baz'</span> // This won<span class="hljs-string">'t pass because foo does not match '</span>ba<span class="hljs-string">r'
};

const nok2 = {
  foo: undefined // This won'</span>t <span class="hljs-keyword">pass</span> because foo <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a string
}</code></pre>
				<a href="#codestringnotimpliescode" id="codestringnotimpliescode" style="color: inherit; text-decoration: none;">
					<h5><code>stringNotImplies</code></h5>
				</a>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  stringNotImplies: {
    simpleValue: {
      foo: <span class="hljs-string">'bar*'</span>
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: <span class="hljs-string">'baz'</span> <span class="hljs-comment">// This will pass because foo does not match 'bar'</span>
};

<span class="hljs-keyword">const</span> nok = {
  foo: <span class="hljs-string">'bar'</span> <span class="hljs-comment">// This won't pass because foo matches 'bar'</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  foo: <span class="hljs-string">'barack'</span> <span class="hljs-comment">// This won't pass because foo matches 'bar'</span>
};

<span class="hljs-keyword">const</span> nok3 = {
  foo: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// This won't pass because foo is not a string</span>
}</code></pre>
				<a href="#number-operators" id="number-operators" style="color: inherit; text-decoration: none;">
					<h4>Number operators</h4>
				</a>
				<a href="#codenumberequalscode" id="codenumberequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>numberEquals</code></h5>
				</a>
				<pre><code>const condition = {
<span class="hljs-symbol">  numberEquals:</span> {
<span class="hljs-symbol">    simpleValue:</span> {
<span class="hljs-symbol">      foo:</span> <span class="hljs-string">'1'</span>
    }
  }
};


const ok = {
<span class="hljs-symbol">  foo:</span> <span class="hljs-number">1</span> <span class="hljs-comment">// This will pass because foo === 1</span>
};

const nok = {
<span class="hljs-symbol">  foo:</span> <span class="hljs-number">2</span> <span class="hljs-comment">// This won't pass because foo !== 1</span>
};

const nok2 = {
<span class="hljs-symbol">  foo:</span> undefined <span class="hljs-comment">// This won't pass because foo is not a number</span>
}</code></pre>
				<a href="#codenumbernotequalscode" id="codenumbernotequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>numberNotEquals</code></h5>
				</a>
				<pre><code>const condition = {
<span class="hljs-symbol">  numberNotEquals:</span> {
<span class="hljs-symbol">    simpleValue:</span> {
<span class="hljs-symbol">      foo:</span> <span class="hljs-string">'0'</span>
    }
  }
};


const ok = {
<span class="hljs-symbol">  foo:</span> <span class="hljs-number">1</span> <span class="hljs-comment">// This will pass because foo !== 1</span>
};

const nok = {
<span class="hljs-symbol">  foo:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// This won't pass because foo === 0</span>
};

const nok2 = {
<span class="hljs-symbol">  foo:</span> undefined <span class="hljs-comment">// This won't pass because foo is not a number</span>
}</code></pre>
				<a href="#codenumbergreaterthancode--codenumbergreaterthanequalscode" id="codenumbergreaterthancode--codenumbergreaterthanequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>numberGreaterThan</code> / <code>numberGreaterThanEquals</code></h5>
				</a>
				<pre><code>const condition = {
<span class="hljs-symbol">  numberGreaterThan:</span> {
<span class="hljs-symbol">    simpleValue:</span> {
<span class="hljs-symbol">      foo:</span> <span class="hljs-string">'0'</span>
    }
  }
};


const ok = {
<span class="hljs-symbol">  foo:</span> <span class="hljs-number">1</span> <span class="hljs-comment">// This will pass because foo &gt; 1</span>
};

const nok = {
<span class="hljs-symbol">  foo:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// This won't pass because foo === 0</span>
};

const nok2 = {
<span class="hljs-symbol">  foo:</span> undefined <span class="hljs-comment">// This won't pass because foo is not a number</span>
}</code></pre>
				<a href="#codenumberlowerthancode--codenumberlowerthanequalscode" id="codenumberlowerthancode--codenumberlowerthanequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>numberLowerThan</code> / <code>numberLowerThanEquals</code></h5>
				</a>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  numberLowerThan: {
    simpleValue: {
      foo: <span class="hljs-string">'100'</span>
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: <span class="hljs-number">1</span> <span class="hljs-comment">// This will pass because foo &lt; 100</span>
};

<span class="hljs-keyword">const</span> nok = {
  foo: <span class="hljs-number">101</span> <span class="hljs-comment">// This won't pass because foo &gt; 0</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  foo: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// This won't pass because foo is not a number</span>
}</code></pre>
				<a href="#codeboolcode" id="codeboolcode" style="color: inherit; text-decoration: none;">
					<h4><code>bool</code></h4>
				</a>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  bool: {
    simpleValue: {
      foo: <span class="hljs-string">'true'</span>
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: <span class="hljs-literal">true</span> <span class="hljs-comment">// This will pass because foo is true</span>
};

<span class="hljs-keyword">const</span> nok = {
  foo: <span class="hljs-literal">false</span> <span class="hljs-comment">// This won't pass because foo is not true</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  foo: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// This won't pass because foo is not a boolean</span>
}</code></pre>
				<a href="#codenullcode" id="codenullcode" style="color: inherit; text-decoration: none;">
					<h4><code>null</code></h4>
				</a>
				<pre><code><span class="hljs-string">const</span> <span class="hljs-string">condition</span> <span class="hljs-string">=</span> <span class="hljs-string">{</span>
  <span class="hljs-attr">null:</span> <span class="hljs-string">{</span>
    <span class="hljs-attr">simpleValue:</span> <span class="hljs-string">{</span>
      <span class="hljs-attr">foo:</span> <span class="hljs-string">'true'</span>
    <span class="hljs-string">}</span>
  <span class="hljs-string">}</span>
<span class="hljs-string">};</span>


<span class="hljs-string">const</span> <span class="hljs-string">ok</span> <span class="hljs-string">=</span> <span class="hljs-string">{</span>
  <span class="hljs-attr">foo:</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-string">This</span> <span class="hljs-string">will</span> <span class="hljs-string">pass</span> <span class="hljs-string">because</span> <span class="hljs-string">foo</span> <span class="hljs-string">is</span> <span class="hljs-literal">null</span>
<span class="hljs-string">};</span>

<span class="hljs-string">const</span> <span class="hljs-string">nok</span> <span class="hljs-string">=</span> <span class="hljs-string">{</span>
  <span class="hljs-attr">foo:</span> <span class="hljs-literal">true</span> <span class="hljs-string">//</span> <span class="hljs-string">This</span> <span class="hljs-string">won't</span> <span class="hljs-string">pass</span> <span class="hljs-string">because</span> <span class="hljs-string">foo</span> <span class="hljs-string">is</span> <span class="hljs-string">not</span> <span class="hljs-literal">null</span>
<span class="hljs-string">};</span>

<span class="hljs-string">const</span> <span class="hljs-string">nok2</span> <span class="hljs-string">=</span> <span class="hljs-string">{</span>
  <span class="hljs-attr">foo:</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-string">This</span> <span class="hljs-string">won't</span> <span class="hljs-string">pass</span> <span class="hljs-string">because</span> <span class="hljs-string">foo</span> <span class="hljs-string">is</span> <span class="hljs-string">not</span> <span class="hljs-literal">null</span>
<span class="hljs-string">}</span></code></pre>
				<a href="#date-operators" id="date-operators" style="color: inherit; text-decoration: none;">
					<h4>Date operators</h4>
				</a>
				<a href="#codedateequalscode" id="codedateequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>dateEquals</code></h5>
				</a>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  <span class="hljs-attr">dateEquals</span>: {
    <span class="hljs-attr">simpleValue</span>: {
      <span class="hljs-attr">foo</span>: <span class="hljs-string">'2018-09-21T09:46:12.441Z'</span>
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">'2018-09-21T09:46:12.441Z'</span> <span class="hljs-comment">// This will pass because matches the contidion value</span>
};

<span class="hljs-keyword">const</span> ok2 = {
  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2018-09-21T09:46:12.441Z'</span>) <span class="hljs-comment">// This will pass because matches the contidion value</span>
};

<span class="hljs-keyword">const</span> ok2 = {
  <span class="hljs-attr">foo</span>: <span class="hljs-number">1537523172441</span> <span class="hljs-comment">// This will pass because matches the contidion value</span>
};

<span class="hljs-keyword">const</span> nok = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">'2017-09-21T09:46:12.441Z'</span> <span class="hljs-comment">// This won't pass because foo does not match the condition value</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  <span class="hljs-attr">foo</span>: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// This won't pass because foo is not castable to a date</span>
}</code></pre>
				<a href="#codedatenotequalscode" id="codedatenotequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>dateNotEquals</code></h5>
				</a>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  <span class="hljs-attr">dateNotEquals</span>: {
    <span class="hljs-attr">simpleValue</span>: {
      <span class="hljs-attr">foo</span>: <span class="hljs-string">'2018-09-21T09:46:12.441Z'</span>
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">'2017-09-21T09:46:12.441Z'</span> <span class="hljs-comment">// This will pass because is different from the contidion value</span>
};

<span class="hljs-keyword">const</span> ok2 = {
  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2017-09-21T09:46:12.441Z'</span>) <span class="hljs-comment">// This will pass because is different from the contidion value</span>
};

<span class="hljs-keyword">const</span> ok2 = {
  <span class="hljs-attr">foo</span>: <span class="hljs-number">1437523172441</span> <span class="hljs-comment">// This will pass because is different from the contidion value</span>
};

<span class="hljs-keyword">const</span> nok = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">'2017-09-21T09:46:12.441Z'</span> <span class="hljs-comment">// This won't pass because foo does matches the condition value</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  <span class="hljs-attr">foo</span>: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// This won't pass because foo is not castable to a date</span>
}</code></pre>
				<a href="#codedategreaterthancode--codedategreaterthanequalscode" id="codedategreaterthancode--codedategreaterthanequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>dateGreaterThan</code> / <code>dateGreaterThanEquals</code></h5>
				</a>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  dateGreaterThan: {
    simpleValue: {
      foo: <span class="hljs-string">'2018-09-21T09:46:12.441Z'</span>
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: <span class="hljs-string">'2019-09-21T09:46:12.441Z'</span> <span class="hljs-comment">// This will pass because foo &gt; condition value</span>
};

<span class="hljs-keyword">const</span> nok = {
  foo: <span class="hljs-string">'2017-09-21T09:46:12.441Z'</span> <span class="hljs-comment">// This won't pass because foo &lt; condition value</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  foo: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// This won't pass because foo is not a date</span>
}</code></pre>
				<a href="#codedatelowerthancode--codedatelowerthanequalscode" id="codedatelowerthancode--codedatelowerthanequalscode" style="color: inherit; text-decoration: none;">
					<h5><code>dateLowerThan</code> / <code>dateLowerThanEquals</code></h5>
				</a>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  dateLowerThan: {
    simpleValue: {
      foo: <span class="hljs-string">'2018-09-21T09:46:12.441Z'</span>
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: <span class="hljs-string">'2017-09-21T09:46:12.441Z'</span> <span class="hljs-comment">// This will pass because foo &lt; condition value</span>
};

<span class="hljs-keyword">const</span> nok = {
  foo: <span class="hljs-string">'2019-09-21T09:46:12.441Z'</span> <span class="hljs-comment">// This won't pass because foo &gt; condition value</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  foo: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// This won't pass because foo is not a date</span>
}</code></pre>
				<a href="#condition-modifiers" id="condition-modifiers" style="color: inherit; text-decoration: none;">
					<h3>Condition modifiers</h3>
				</a>
				<p>Condition modifiers are largely inspired by AWS IAM policies, with some minor additions (see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_multi-value-conditions.html">https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_multi-value-conditions.html</a> and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition_operators.html">https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition_operators.html</a>).</p>
				<p>We support 6 modifiers:</p>
				<ul>
					<li><code>simpleValue</code></li>
					<li><code>simpleValueIfExists</code></li>
					<li><code>forAllValues</code></li>
					<li><code>forAllValuesIfExists</code></li>
					<li><code>forAnyValue</code></li>
					<li><code>forAnyValueIfExists</code></li>
				</ul>
				<a href="#modifiers-that-check-a-single-value" id="modifiers-that-check-a-single-value" style="color: inherit; text-decoration: none;">
					<h4>Modifiers that check a single value</h4>
				</a>
				<a href="#codesimplevaluecode" id="codesimplevaluecode" style="color: inherit; text-decoration: none;">
					<h5><code>simpleValue</code></h5>
				</a>
				<pre><code>const condition = {
  stringEquals: {
    simpleValue: {
      foo: <span class="hljs-string">'bar'</span>
    }
  }
};


const ok = {
  foo: <span class="hljs-string">'bar'</span> <span class="hljs-regexp">//</span> This will pass because foo === <span class="hljs-string">'bar'</span>
};

const nok = {
  foo: <span class="hljs-string">'baz'</span> <span class="hljs-regexp">//</span> This won<span class="hljs-string">'t pass because foo !== '</span>ba<span class="hljs-string">r'
};

const nok2 = {
  foo: undefined // This won'</span>t pass because foo !== <span class="hljs-string">'bar'</span>
}</code></pre>
				<a href="#codesimplevalueifexistscode" id="codesimplevalueifexistscode" style="color: inherit; text-decoration: none;">
					<h5><code>simpleValueIfExists</code></h5>
				</a>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  stringEquals: {
    simpleValueIfExists: {
      foo: <span class="hljs-string">'bar'</span>
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: <span class="hljs-string">'bar'</span> <span class="hljs-comment">// This will pass because foo === 'bar'</span>
};

<span class="hljs-keyword">const</span> ok2 = {
  foo: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// This will pass because foo does not exist</span>
}

<span class="hljs-keyword">const</span> nok = {
  foo: <span class="hljs-string">'baz'</span> <span class="hljs-comment">// This won't pass because foo !== 'bar'</span>
};
</code></pre>
				<a href="#modifiers-that-check-multiple-values" id="modifiers-that-check-multiple-values" style="color: inherit; text-decoration: none;">
					<h4>Modifiers that check multiple values</h4>
				</a>
				<a href="#codeforallvaluescode" id="codeforallvaluescode" style="color: inherit; text-decoration: none;">
					<h5><code>forAllValues</code></h5>
				</a>
				<p>This modifier enforces that all values - if any - present in the environment must match a value in the condition.</p>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  stringEquals: {
    forAllValues: {
      foo: [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'boo'</span>]
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: [<span class="hljs-string">'bar'</span>] <span class="hljs-comment">// This will pass because foo is "one of" the condition's value</span>
};

<span class="hljs-keyword">const</span> ok2 = {
  foo: [] <span class="hljs-comment">// This will pass because no value in foo contradicts the condition's values</span>
};

<span class="hljs-keyword">const</span> nok = {
  foo: [<span class="hljs-string">'booz'</span>, <span class="hljs-string">'bar'</span>] <span class="hljs-comment">// This won't pass because booz is not listed in the condition's values</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  foo: [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">// This won't pass because undefined is not an allowed value</span>
}</code></pre>
				<a href="#codeforallvaluesifexistscode" id="codeforallvaluesifexistscode" style="color: inherit; text-decoration: none;">
					<h5><code>forAllValuesIfExists</code></h5>
				</a>
				<p>This modifier does exactly the same thing as <code>forAllValues</code> expect that it ignores undefined values.</p>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  stringEquals: {
    forAllValuesIfExists: {
      foo: [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'boo'</span>]
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: [<span class="hljs-string">'bar'</span>] <span class="hljs-comment">// This will pass because foo is "one of" the condition's value</span>
};

<span class="hljs-keyword">const</span> ok2 = {
  foo: [] <span class="hljs-comment">// This will pass because no value in foo contradicts the condition's values</span>
};

<span class="hljs-keyword">const</span> ok3 = {
  foo: [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">// This will pass because only "existing" values are evaluated</span>
}

<span class="hljs-keyword">const</span> nok = {
  foo: [<span class="hljs-string">'booz'</span>, <span class="hljs-string">'bar'</span>] <span class="hljs-comment">// This won't pass because booz is not listed in the condition's values</span>
};</code></pre>
				<a href="#codeforanyvaluecode" id="codeforanyvaluecode" style="color: inherit; text-decoration: none;">
					<h5><code>forAnyValue</code></h5>
				</a>
				<p>This modifier says that the condition is met if at least one value in the environment matches the accepted values in the condition.</p>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  stringEquals: {
    forAnyValue: {
      foo: [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'boo'</span>]
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'booz'</span>] <span class="hljs-comment">// This will pass because bar is an accepted value</span>
};

<span class="hljs-keyword">const</span> ok2 = {
  foo: [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>] <span class="hljs-comment">// This will pass because all values are accepted</span>
};

<span class="hljs-keyword">const</span> nok = {
  foo: [<span class="hljs-string">'booz'</span>, <span class="hljs-string">'biz'</span>] <span class="hljs-comment">// This won't pass because no value matches the condition values</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  foo: [] <span class="hljs-comment">// This won't pass because no value in foo matches a condition value</span>
};</code></pre>
				<a href="#codeforanyvalueifexistscode" id="codeforanyvalueifexistscode" style="color: inherit; text-decoration: none;">
					<h5><code>forAnyValueIfExists</code></h5>
				</a>
				<p>You will most likely never use this modifier unless you expect the environment values to be a mix of valid and undefined values.</p>
				<pre><code><span class="hljs-keyword">const</span> condition = {
  stringEquals: {
    forAnyValueIfExists: {
      foo: [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>, <span class="hljs-string">'boo'</span>]
    }
  }
};


<span class="hljs-keyword">const</span> ok = {
  foo: [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'booz'</span>, <span class="hljs-literal">undefined</span>] <span class="hljs-comment">// This will pass because bar is an accepted value</span>
};

<span class="hljs-keyword">const</span> nok = {
  foo: [<span class="hljs-string">'booz'</span>, <span class="hljs-string">'biz'</span>] <span class="hljs-comment">// This won't pass because no value matches the condition values</span>
};

<span class="hljs-keyword">const</span> nok2 = {
  foo: [] <span class="hljs-comment">// This won't pass because no value in foo matches a condition value</span>
};

<span class="hljs-keyword">const</span> nok3 = {
  foo: [<span class="hljs-literal">undefined</span>] <span class="hljs-comment">// This is equivalent to an empty array</span>
};</code></pre>
				<a href="#condition-variables" id="condition-variables" style="color: inherit; text-decoration: none;">
					<h3>Condition variables</h3>
				</a>
				<p>Bluejay provides us with a powerful way of defining variables as condition values, making permissions dynamic.</p>
				<p>Let&#39;s say that we want to expose an endpoint and allows our users to modify their information. We need to make sure that a given user can only modify their own information, and no one else&#39;s. A naive way of defining permissions would look like the following.</p>
				<pre><code class="language-typescript">store
  .addPermissionToRole(Role.CUSTOMER, {
    id: <span class="hljs-string">'CustomerUpdateInformationPolicy'</span>,
    effect: <span class="hljs-string">'allow'</span>,
    resource: <span class="hljs-string">'users'</span>,
    action: <span class="hljs-string">'update'</span>,
    condition: {
      numberEquals: {
        simpleValue: {
          id: <span class="hljs-string">'?????'</span> <span class="hljs-comment">// Here we would need to create one permission per user!</span>
        }
      }
    }
  })</code></pre>
				<p>Thanks to Bluejay&#39;s variables, we have a more dynamic way of doing this.</p>
				<pre><code class="language-typescript">store
  .addPermissionToRole(Role.CUSTOMER, {
    id: <span class="hljs-string">'CustomerUpdateInformationPolicy'</span>,
    effect: <span class="hljs-string">'allow'</span>,
    resource: <span class="hljs-string">'users'</span>,
    action: <span class="hljs-string">'update'</span>,
    condition: {
      numberEquals: {
        simpleValue: {
          <span class="hljs-string">'params.id'</span>: <span class="hljs-string">'{{{subject.id}}}'</span> <span class="hljs-comment">// This will be evaluated at runtime</span>
        }
      }
    }
  })</code></pre>
				<p>Now let&#39;s look at the endpoint itself.</p>
				<pre><code class="language-typescript">app.patch(<span class="hljs-string">'/users/:id'</span>, authenticate(), validatePatchBody(), <span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
  <span class="hljs-keyword">const</span> body: Partial&lt;IPost&gt; = req.body;

  <span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> UserSubject(req.user);

  <span class="hljs-comment">// We're passing both the id and the subject to the environment</span>
  <span class="hljs-keyword">const</span> isAllowed = <span class="hljs-keyword">await</span> accessControl.can(subject, <span class="hljs-string">'posts'</span>, <span class="hljs-string">'create'</span>, { params: req.params, subject: subject.toJSON() });

  <span class="hljs-comment">// An admin user will be allowed to update any user. The id and subject in the environment will not even be used since no condition is defined.</span>
  <span class="hljs-comment">// A customer, on the other side, will only be able to update their own user.</span>

  <span class="hljs-keyword">if</span> (isAllowed) {
    <span class="hljs-keyword">await</span> userService.update({ id: req.params.id }, body);
    res.status(<span class="hljs-number">204</span>).end();
  } <span class="hljs-keyword">else</span> {
    res.status(<span class="hljs-number">403</span>).end();
  }
});</code></pre>
				<a href="#filtering-returned-attributes" id="filtering-returned-attributes" style="color: inherit; text-decoration: none;">
					<h3>Filtering returned attributes</h3>
				</a>
				<p>It is important to understand that access control validates a request and has therefore no influence over the response that you send to your consumers.</p>
				<p>If you need to control which fields are exposed in the responses to your different consumers, one solution is to have them explicitly request the set of attributes that they want to see returned. If this is how your application behaves, then you can validate the attributes that a particular user is requesting using a permission that would look like this:</p>
				<pre><code class="language-typescript">ac.addPermissionToRole(Role.CUSTOMER, {
  id: <span class="hljs-string">'CustomerReadPostPolicy'</span>,
  effect: <span class="hljs-string">'allow'</span>,
  resource: <span class="hljs-string">'posts'</span>,
  action: <span class="hljs-string">'read'</span>,
  condition: {
    stringEquals: {
      forAllValues: {
        fields: [<span class="hljs-string">'id'</span>, <span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>, <span class="hljs-string">'created_by'</span>]
      }
    }
  }
});</code></pre>
				<p>In this condition, we are essentially saying that <em>for all values</em> in <code>fields</code>, we expect to find an <em>equal string</em> in the permission&#39;s values.</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// We'll assume that the consumers make calls that look like "GET /posts?fields=id,title,content" where the `fields` query parameter defines the fields to be returned as a response.</span>

app.get(<span class="hljs-string">'/posts'</span>, authenticate(), <span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
  <span class="hljs-keyword">const</span> fields = (req.query.fields || <span class="hljs-string">''</span>).split(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> UserSubject(req.user);

  <span class="hljs-comment">// We're passing the fields in the environment hash so that they can be evaluated</span>
  <span class="hljs-keyword">const</span> access = <span class="hljs-keyword">await</span> accessControl.authorize(subject, <span class="hljs-string">'posts'</span>, <span class="hljs-string">'read'</span>, { fields });

  <span class="hljs-keyword">if</span> (access.isAllowed()) {
    <span class="hljs-comment">// The application is responsible for only returning the fields that have been requested. The access control has made sure that only allowed attributes have been requested, so you can safely pass the fields to your service.</span>
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> postService.list({ fields });
    res.status(<span class="hljs-number">200</span>).json(data);
  } <span class="hljs-keyword">else</span> {
    res.status(<span class="hljs-number">403</span>).end();
  }
});</code></pre>
				<p>However, in most applications, the consumer is not expected to provide the fields they want to see returned. Bluejay provides you with a convenient way of dealing with this use case by introducing a special <code>returnedAttributes</code> property in the permission definition. With this knowledge, we can refactor the previous permission to this one:</p>
				<pre><code class="language-typescript">ac.addPermissionToRole(Role.CUSTOMER, {
  id: <span class="hljs-string">'CustomerReadPostPolicy'</span>,
  effect: <span class="hljs-string">'allow'</span>,
  resource: <span class="hljs-string">'posts'</span>,
  action: <span class="hljs-string">'read'</span>,
  returnedAttributes: [<span class="hljs-string">'id'</span>, <span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>, <span class="hljs-string">'created_by'</span>]
});

<span class="hljs-comment">// We'll now assume that consumers make calls that look like "GET /posts".</span>

app.get(<span class="hljs-string">'/posts'</span>, authenticate(), <span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
  <span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> UserSubject(req.user);

  <span class="hljs-comment">// We're not passing any environment data here since the request does not contain any attribute information that could be useful to determine access. the `returnedAttributes` are simply ignored by Bluejay.</span>
  <span class="hljs-keyword">const</span> access = <span class="hljs-keyword">await</span> accessControl.authorize(subject, <span class="hljs-string">'posts'</span>, <span class="hljs-string">'read'</span>);

  <span class="hljs-keyword">if</span> (access.isAllowed()) {
    <span class="hljs-comment">// This time, instead of using the request's `fields`, we're using the fields defined in the permission and accessible through `getReturnedAttributes()` on the access.</span>
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> postService.list({ fields: access.getReturnedAttributes() || [] }); <span class="hljs-comment">// Depending on who's calling, the returned attributes might be undefined</span>
    res.status(<span class="hljs-number">200</span>).json(data);
  } <span class="hljs-keyword">else</span> {
    res.status(<span class="hljs-number">403</span>).end();
  }
});</code></pre>
				<p>It is important to note that Bluejay only acts as a middleman here and never uses <code>returnedAttributes</code> to determine access.</p>
				<p>Also alternatively, if you are not able to have your services only return a specific set of attributes, you can use Bluejay&#39;s <code>Keys</code> utility to filter the payload before responding:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Keys } <span class="hljs-keyword">from</span> <span class="hljs-string">'@bluejay/access-control'</span>;

app.get(<span class="hljs-string">'/posts'</span>, authenticate(), <span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
  <span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> UserSubject(req.user);

  <span class="hljs-comment">// We're not passing any environment data here since the request does not contain any attribute information that could be useful to determine access. the `returnedAttributes` are simply ignored by the authorizer.</span>
  <span class="hljs-keyword">const</span> access = <span class="hljs-keyword">await</span> accessControl.authorize(subject, <span class="hljs-string">'posts'</span>, <span class="hljs-string">'read'</span>);

  <span class="hljs-keyword">if</span> (access.isAllowed()) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> postService.list();

    <span class="hljs-comment">// Keys.filter() accepts both objects and arrays</span>
    <span class="hljs-keyword">const</span> payload = Keys.filter(data, access.getReturnedAttributes())

    res.status(<span class="hljs-number">200</span>).json(payload);
  } <span class="hljs-keyword">else</span> {
    res.status(<span class="hljs-number">403</span>).end();
  }
});</code></pre>
				<a href="#stores" id="stores" style="color: inherit; text-decoration: none;">
					<h3>Stores</h3>
				</a>
				<a href="#the-default-codememorystorecode" id="the-default-codememorystorecode" style="color: inherit; text-decoration: none;">
					<h4>The default <code>MemoryStore</code></h4>
				</a>
				<p>By default, Bluejay comes packaged with a <code>MemoryStore</code> which allows you to quickly get started by storing permissions in memory.</p>
				<ul>
					<li><code>createPermission()</code>: Create/store a new permission. Overrides any existing permission with the same ID. If no <code>id</code> property is set, one will be created</li>
					<li><code>deletePermission()</code>: Delete a single permission</li>
					<li><code>replacePermission()</code>: Replaces a permission by ID</li>
					<li><code>addPermissionToRole()</code>: Assigns a permission to a role. If the permission does not exist yet, it will be created</li>
					<li><code>removePermissionFromRole()</code>: Unassigns a permission from a role</li>
					<li><code>addRoleToSubject()</code>: Assigns a role to a subject</li>
					<li><code>removeRoleFromSubject()</code>: Unassigns a role from a subject</li>
					<li><code>getRolesForSubject()</code>: Lists roles assigned to a subject</li>
					<li><code>getPermissionsForRole()</code>: Lists permissions assigned to a role</li>
					<li><code>getPermissionsForSubject()</code>: Lists permissions assigned to a subject, that is, all permissions attached to the subject&#39;s roles</li>
					<li><code>createSubject()</code>: Creates/stores a subject</li>
					<li><code>deleteSubject()</code>: Deletes a subject</li>
					<li><code>getPermissions()</code>: Lists all permissions</li>
					<li><code>getPermissionById()</code>: Retrieve a permission by ID</li>
					<li><code>getSubjects()</code>: Lists all subjects</li>
					<li><code>getSubjectByPrincipal()</code>: Retrieve a subject by principal</li>
				</ul>
				<a href="#creating-your-own-store-by-implementing-the-codeistorecode-interface" id="creating-your-own-store-by-implementing-the-codeistorecode-interface" style="color: inherit; text-decoration: none;">
					<h4>Creating your own store by implementing the <code>IStore</code> interface</h4>
				</a>
				<p>While the <code>MemoryStore</code> is a convenient way to get started, you will maybe feel the need of storing your permissions in a more persistent storage at some point. A <code>store</code>, as required by the <code>AccessControl</code> constructor, is nothing more than an implementation of the <code>IStore</code> interface, which looks like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IStore {
  getPermissionsForSubject(subject: ISubject&lt;{}&gt;): TPermission[] | <span class="hljs-built_in">Promise</span>&lt;TPermission[]&gt;;
}</code></pre>
				<p>This interface defines a single method that will allow Bluejay to retrieve the permissions assigned to a given subject. It can be either synchronous and return a simple array of permissions or asynchronous by returning a promise that resolves with the list.</p>
				<p>No matter how permissions are stored, Bluejay expects a permission to look like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">type</span> TPermission = {
  id: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;              <span class="hljs-comment">// A unique identifier for this permission</span>
  effect: <span class="hljs-string">'allow'</span> | <span class="hljs-string">'deny'</span>;         <span class="hljs-comment">// Whether this permission allows or denies access</span>
  resource: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[];      <span class="hljs-comment">// Either a list or a single resource</span>
  action: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]];       <span class="hljs-comment">// Either a list or a single action</span>
  returnedAttributes?: <span class="hljs-built_in">string</span>[];    <span class="hljs-comment">// A list of attributes to return</span>
  condition?: TPermissionCondition; <span class="hljs-comment">// A condition that defines whether or not the permission is applicable</span>
}</code></pre>
				<a href="#example-store-implementations" id="example-store-implementations" style="color: inherit; text-decoration: none;">
					<h4>Example store implementations</h4>
				</a>
				<p>While Bluejay does not provide other stores than the memory based one out of the box, we&#39;re going to take a little time in this documentation and provide some guidance.</p>
				<a href="#mongodb" id="mongodb" style="color: inherit; text-decoration: none;">
					<h5>MongoDB</h5>
				</a>
				<p>Because of its native JSON support, it is very simple to store permissions in MongoDB. We could create a collection <code>permissions</code> with a schema that directly maps to the <code>TPermission</code> type. In addition, and in order to store the association between roles and permissions, we&#39;d add a <code>roles</code> property to permissions and end up with a schema that looks like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">type</span> TMongoPermission = {
  _id: <span class="hljs-built_in">string</span>;
  effect: <span class="hljs-string">'allow'</span> | <span class="hljs-string">'deny'</span>;
  resource: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[];
  action: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]];
  returnedAttributes?: <span class="hljs-built_in">string</span>[];
  condition?: TPermissionCondition;
  roles: <span class="hljs-built_in">string</span>[]; <span class="hljs-comment">// Here we store the roles that get assigned the permission</span>
}</code></pre>
				<p>In our application, we probably already have a <code>users</code> collection, which maybe looks like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">type</span> TUser = {
  _id: <span class="hljs-built_in">string</span>;
  email: <span class="hljs-built_in">string</span>;
  first_name: <span class="hljs-built_in">string</span>;
  last_name: <span class="hljs-built_in">string</span>;
  roles: <span class="hljs-built_in">string</span>[]; <span class="hljs-comment">// Here we store the user's roles</span>
}</code></pre>
				<p>Then we can write a simple class to implement the <code>IStore</code> interface.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Db } <span class="hljs-keyword">from</span> <span class="hljs-string">'mongodb'</span>;
<span class="hljs-keyword">import</span> { IStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interfaces/store'</span>;
<span class="hljs-keyword">import</span> { ISubject } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interfaces/subject'</span>;
<span class="hljs-keyword">import</span> { TPermission } <span class="hljs-keyword">from</span> <span class="hljs-string">'./types/permission'</span>;

<span class="hljs-comment">// This should be defined somewhere else in your project.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IApplicationSubject <span class="hljs-keyword">extends</span> ISubject&lt;{ _id: <span class="hljs-built_in">string</span>; }&gt; {

}

<span class="hljs-comment">// This is your custom permission schema.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> TApplicationPermission = TPermission &amp; {
  _id: <span class="hljs-built_in">string</span>;
  roles: <span class="hljs-built_in">string</span>[];
};

<span class="hljs-comment">/**
 * Store implementation for Bluejay access control.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MongoStore <span class="hljs-keyword">implements</span> IStore {
  <span class="hljs-keyword">private</span> db: Db;

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">db: Db</span>) {
    <span class="hljs-keyword">this</span>.db = db;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> getPermissionsForSubject(subject: IApplicationSubject): <span class="hljs-built_in">Promise</span>&lt;TApplicationPermission[]&gt; {
    <span class="hljs-keyword">const</span> userId = subject.get(<span class="hljs-string">'_id'</span>);

    <span class="hljs-comment">// First we find the user in order to get their roles.</span>
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.db.collection(<span class="hljs-string">'users'</span>).findOne&lt;{ roles: <span class="hljs-built_in">string</span>[] }&gt;({
      _id: userId
    }, {
      projection: { roles: <span class="hljs-number">1</span> }
    });

    <span class="hljs-keyword">if</span> (!user) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unknown user: <span class="hljs-subst">${userId}</span>.`</span>);
    }

    <span class="hljs-comment">// Then we find the permissions that correspond to those roles.</span>
    <span class="hljs-keyword">const</span> permissionsCursor = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.db.collection(<span class="hljs-string">'permissions'</span>).find&lt;TApplicationPermission&gt;({
      role: { <span class="hljs-keyword">in</span>: user.roles }
    });

    <span class="hljs-comment">// That's it!</span>
    <span class="hljs-keyword">return</span> permissionsCursor.toArray();
  }

}
</code></pre>
				<p>Then to use the store:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">'./db'</span>; <span class="hljs-comment">// We'll assume that you already have an instance exported.</span>

<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> MongoStore(db);
<span class="hljs-keyword">const</span> accessControl = <span class="hljs-keyword">new</span> AccessControl({ store });</code></pre>
				<p>That&#39;s it! Now each time Bluejay needs to know which permissions are associated with a user, it will fetch the data from your Mongo store.</p>
				<p><strong>Note</strong>: We do not detail advanced methods to manage (create/update) your permissions as this is something you should control. If you&#39;re looking for inspiration though, have a look at the <a href="./src/classes/memory-store.ts">MemoryStore</a>.</p>
				<a href="#mysql" id="mysql" style="color: inherit; text-decoration: none;">
					<h5>MySQL</h5>
				</a>
				<p>TODO</p>
				<a href="#returned-attributes-in-depth-pattern-matching-and-the-codekeyscode-utility" id="returned-attributes-in-depth-pattern-matching-and-the-codekeyscode-utility" style="color: inherit; text-decoration: none;">
					<h3>Returned attributes in depth: pattern matching and the <code>Keys</code> utility</h3>
				</a>
				<p>The following examples apply to systems where the returned attributes are manually filtered using the <code>Keys.filter()</code> utility.</p>
				<p>Bluejay uses a proprietary syntax for describing <code>returnedAttributes</code> in combination with <code>Keys</code>. The reason is that we want to offer a custom-fit experience when dealing with those attributes as well as make sure that we only perform necessary operations in order to obtain the best possible performance.</p>
				<p>The examples below use a data structure that describes a blog post with various attributes.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">type</span> BlogPost = {
  id: <span class="hljs-built_in">number</span>:
  title: <span class="hljs-built_in">string</span>;
  content: <span class="hljs-built_in">string</span>;
  author: {
    id: <span class="hljs-built_in">number</span>;
    username: <span class="hljs-built_in">string</span>;
    email: <span class="hljs-built_in">string</span>;
    hobbies: <span class="hljs-built_in">string</span>[];
  },
  comments: {
    id: <span class="hljs-built_in">number</span>;
    content: <span class="hljs-built_in">string</span>;
    author: {
      id: <span class="hljs-built_in">number</span>;
      username: <span class="hljs-built_in">string</span>;
      email: <span class="hljs-built_in">string</span>;
      hobbies: <span class="hljs-built_in">string</span>[];
    }
  }[];
}</code></pre>
				<a href="#whitelist-approach" id="whitelist-approach" style="color: inherit; text-decoration: none;">
					<h4>Whitelist approach</h4>
				</a>
				<p>Whitelisting is the recommended way to describe your returned attributes, because it offers you the peace of mind and clarity of knowing what exactly is being returned to your user.</p>
				<p>Let&#39;s say we want the author of a blog post to receive all information about a blog post except the email addresses of the comments authors. We would write the returned attributes as such:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> permission: TPermission = {
  id: <span class="hljs-string">'User:BlogPost:GetItem'</span>,
  resource: <span class="hljs-string">'blog-posts'</span>,
  action: <span class="hljs-string">'get-item'</span>,
  effect: PermissionEffect.ALLOW,
  returnedAttributes: [
    <span class="hljs-string">'id'</span>,
    <span class="hljs-string">'title'</span>,
    <span class="hljs-string">'content'</span>,
    <span class="hljs-string">'author.id'</span>,
    <span class="hljs-string">'author.username'</span>,
    <span class="hljs-string">'author.email'</span>,
    <span class="hljs-string">'author.hobbies'</span>,
    <span class="hljs-string">'comments.[].id'</span>,
    <span class="hljs-string">'comments.[].content'</span>,
    <span class="hljs-string">'comments.[].author.id'</span>,
    <span class="hljs-string">'comments.[].author.username'</span>,
    <span class="hljs-string">'comments.[].author.hobbies'</span>,
 ]
};</code></pre>
				<p>Because we omitted <code>comments.[].author.email</code>, the user won&#39;t see the commenters emails, assuming that we filtered the payload using <code>Keys.filter()</code>.</p>
				<a href="#the-codecode-bang-operator-or-the-blacklist-approach" id="the-codecode-bang-operator-or-the-blacklist-approach" style="color: inherit; text-decoration: none;">
					<h4>The <code>!</code> (bang) operator or the blacklist approach</h4>
				</a>
				<p>While the whitelist approach provides the most security, there are times where you will prefer to not describe all fields but rather exclude particular fields from the payload. Here comes the <code>!</code> operator. In order to obtain the exact same result as previously, we could rewrite the permission as such:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> permission: TPermission = {
  id: <span class="hljs-string">'User:BlogPost:GetItem'</span>,
  resource: <span class="hljs-string">'blog-posts'</span>,
  action: <span class="hljs-string">'get-item'</span>,
  effect: PermissionEffect.ALLOW,
  returnedAttributes: [
    <span class="hljs-string">'!comments.[].author.email'</span>,
  ]
};</code></pre>
				<p>Magic!</p>
				<p><em>Note:</em> It is not possible to combine the whitelist and blacklist approaches in a given <code>returnedAttributes</code> array</p>
				<a href="#the-codecode-wild-card-operator" id="the-codecode-wild-card-operator" style="color: inherit; text-decoration: none;">
					<h4>The <code>*</code> (wild card) operator</h4>
				</a>
				<p>The simplest and most permissive <code>returnedAttributes</code> can be written as such:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> permission: TPermission = {
  id: <span class="hljs-string">'User:BlogPost:GetItem'</span>,
  resource: <span class="hljs-string">'blog-posts'</span>,
  action: <span class="hljs-string">'get-item'</span>,
  effect: PermissionEffect.ALLOW,
  returnedAttributes: <span class="hljs-string">'*'</span>
};</code></pre>
				<p>This basically means: return everything.</p>
				<p>We could also want to simplify part of the returned attributes by combining the whitelist approach and the wild cards. We could for example rewrite the initial example as such:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> permission: TPermission = {
  id: <span class="hljs-string">'User:BlogPost:GetItem'</span>,
  resource: <span class="hljs-string">'blog-posts'</span>,
  action: <span class="hljs-string">'get-item'</span>,
  effect: PermissionEffect.ALLOW,
  returnedAttributes: [
    <span class="hljs-string">'id'</span>,
    <span class="hljs-string">'title'</span>,
    <span class="hljs-string">'content'</span>,
    <span class="hljs-string">'author.*'</span>,
    <span class="hljs-string">'comments.[].id'</span>,
    <span class="hljs-string">'comments.[].content'</span>,
    <span class="hljs-string">'comments.[].author.id'</span>,
    <span class="hljs-string">'comments.[].author.username'</span>,
    <span class="hljs-string">'comments.[].author.hobbies'</span>,
 ]
};</code></pre>
				<p>Notice the <code>author.*</code> that basically says: returned everything in the nested <code>author</code> object. Note that this doesn&#39;t have any influence over the nested <code>author</code> objects in the <code>comments</code>, but exclusively at the root of the object.</p>
				<p><em>Info:</em> When you use the blacklist approach, a <code>returnedAttributes</code> with a value of <code>[&#39;!comments.[].author.email&#39;]</code> is essentially equivalent to <code>[&#39;*&#39;, &#39;!comments.[].author.email&#39;]</code></p>
				<a href="#arrays-and-the-codecode-unwind-operator" id="arrays-and-the-codecode-unwind-operator" style="color: inherit; text-decoration: none;">
					<h4>Arrays and the <code>[]</code> (unwind) operator</h4>
				</a>
				<p>You may have noticed the particular syntax for the <code>comments</code> array in the previous examples. This operator allows us to say &quot;for each element in the array, apply the following pattern&quot;. It is particularly useful when dealing with lists of objects with no predefined length.</p>
				<p>When dealing with tuples though, each element in the array can be referenced by its index. Let&#39;s say, for example, that we only want users to receive the first comment from the <code>comments</code> array. We would write the permission as such:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> permission: TPermission = {
  id: <span class="hljs-string">'User:BlogPost:GetItem'</span>,
  resource: <span class="hljs-string">'blog-posts'</span>,
  action: <span class="hljs-string">'get-item'</span>,
  effect: PermissionEffect.ALLOW,
  returnedAttributes: [
    <span class="hljs-string">'id'</span>,
    <span class="hljs-string">'title'</span>,
    <span class="hljs-string">'content'</span>,
    <span class="hljs-string">'author.*'</span>,
    <span class="hljs-string">'comments.0.id'</span>,
    <span class="hljs-string">'comments.0.content'</span>,
    <span class="hljs-string">'comments.0.author.id'</span>,
    <span class="hljs-string">'comments.0.author.username'</span>,
    <span class="hljs-string">'comments.0.author.hobbies'</span>,
 ]
};</code></pre>
				<p>This will ensure that only the first comment is returned.</p>
				<a href="#inspirations" id="inspirations" style="color: inherit; text-decoration: none;">
					<h2>Inspirations</h2>
				</a>
				<p>Special heads up to the following modules and their creators for the precious inspiration:</p>
				<ul>
					<li><a href="https://shiro.apache.org/index.html">Apache Shiro</a></li>
					<li><a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html">AWS IAM</a></li>
					<li><a href="https://onury.io/accesscontrol/?content=guide">AccessControl</a></li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>